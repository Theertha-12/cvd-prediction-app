{"ast":null,"code":"import api from './api';\nexport const getDashboardData = async userRole => {\n  try {\n    // CRITICAL FIX: Always ensure fresh data by adding cache-busting parameter\n    const timestamp = Date.now();\n    const userId = localStorage.getItem('current_user_id');\n    console.log(`ðŸ“Š Fetching fresh dashboard data for user ${userId}, role: ${userRole}`);\n\n    // Try the specific role endpoint first with cache-busting\n    const primaryEndpoint = userRole === 'doctor' ? '/dashboard/doctor' : '/dashboard/patient';\n    console.log(`ðŸ“Š Trying primary dashboard endpoint: ${primaryEndpoint}`);\n    const response = await api.get(primaryEndpoint, {\n      params: {\n        _t: timestamp,\n        // Cache-busting parameter\n        user_id: userId // Explicit user context\n      }\n    });\n    console.log('âœ… Dashboard API response:', response.data);\n\n    // CRITICAL FIX: Validate that data belongs to current user\n    if (response.data.user_info && userId) {\n      var _response$data$user_i;\n      const responseUserId = (_response$data$user_i = response.data.user_info.id) === null || _response$data$user_i === void 0 ? void 0 : _response$data$user_i.toString();\n      if (responseUserId && responseUserId !== userId) {\n        console.error('ðŸš¨ SECURITY ALERT: Response data belongs to different user!');\n        throw new Error('Data mismatch - please refresh and try again');\n      }\n    }\n\n    // Validate response structure\n    if (!response.data) {\n      throw new Error('No data received from server');\n    }\n\n    // Ensure required fields exist with user context validation\n    const data = {\n      user_info: response.data.user_info || {},\n      statistics: response.data.statistics || {\n        total_predictions: 0,\n        recent_predictions: 0,\n        recent_activity: 0,\n        total_patients: userRole === 'doctor' ? 0 : null,\n        risk_distribution: {\n          High: 0,\n          Moderate: 0,\n          Low: 0\n        }\n      },\n      latest_prediction: response.data.latest_prediction || null,\n      recent_predictions: response.data.recent_predictions || [],\n      recent_activities: response.data.recent_activities || [],\n      _fetched_at: new Date().toISOString(),\n      // Track when data was fetched\n      _user_id: userId // Track which user this data belongs to\n    };\n    return data;\n  } catch (error) {\n    console.error('Primary dashboard endpoint failed:', error);\n\n    // CRITICAL FIX: Don't try fallbacks if it's a user data mismatch\n    if (error.message.includes('Data mismatch')) {\n      throw error;\n    }\n\n    // Try fallback endpoints with same cache-busting and user validation\n    const fallbackEndpoints = ['/dashboard', '/api/dashboard', `/api/dashboard/${userRole}`];\n    const timestamp = Date.now();\n    const userId = localStorage.getItem('current_user_id');\n    for (const endpoint of fallbackEndpoints) {\n      try {\n        console.log(`ðŸ“Š Trying fallback endpoint: ${endpoint}`);\n        const response = await api.get(endpoint, {\n          params: {\n            _t: timestamp,\n            user_id: userId\n          }\n        });\n        console.log(`âœ… Success with fallback endpoint: ${endpoint}`);\n\n        // Validate user data again\n        if (response.data.user_info && userId) {\n          var _response$data$user_i2;\n          const responseUserId = (_response$data$user_i2 = response.data.user_info.id) === null || _response$data$user_i2 === void 0 ? void 0 : _response$data$user_i2.toString();\n          if (responseUserId && responseUserId !== userId) {\n            console.error('ðŸš¨ SECURITY ALERT: Fallback response data belongs to different user!');\n            continue; // Try next endpoint\n          }\n        }\n        const data = {\n          user_info: response.data.user_info || {},\n          statistics: response.data.statistics || {\n            total_predictions: 0,\n            recent_predictions: 0,\n            recent_activity: 0,\n            total_patients: userRole === 'doctor' ? 0 : null,\n            risk_distribution: {\n              High: 0,\n              Moderate: 0,\n              Low: 0\n            }\n          },\n          latest_prediction: response.data.latest_prediction || null,\n          recent_predictions: response.data.recent_predictions || [],\n          recent_activities: response.data.recent_activities || [],\n          _fetched_at: new Date().toISOString(),\n          _user_id: userId\n        };\n        return data;\n      } catch (fallbackError) {\n        var _fallbackError$respon;\n        console.log(`âŒ Fallback endpoint ${endpoint} failed:`, (_fallbackError$respon = fallbackError.response) === null || _fallbackError$respon === void 0 ? void 0 : _fallbackError$respon.status);\n        continue;\n      }\n    }\n\n    // If all endpoints fail, try to construct from other APIs with user validation\n    console.log('ðŸ“Š All dashboard endpoints failed, trying to construct from other APIs...');\n    return await constructDashboardFromOtherAPIs(userRole);\n  }\n};\n\n// CRITICAL FIX: Enhanced fallback with user validation\nconst constructDashboardFromOtherAPIs = async userRole => {\n  try {\n    console.log('ðŸ“Š Constructing dashboard from available APIs...');\n    const timestamp = Date.now();\n    const userId = localStorage.getItem('current_user_id');\n    const dashboardData = {\n      user_info: {},\n      statistics: {\n        total_predictions: 0,\n        recent_predictions: 0,\n        recent_activity: 0,\n        total_patients: userRole === 'doctor' ? 0 : null,\n        risk_distribution: {\n          High: 0,\n          Moderate: 0,\n          Low: 0\n        }\n      },\n      latest_prediction: null,\n      recent_predictions: [],\n      recent_activities: [],\n      _fetched_at: new Date().toISOString(),\n      _user_id: userId\n    };\n\n    // Try to get user info with cache-busting\n    try {\n      var _userResponse$data$id;\n      const userResponse = await api.get('/user/profile', {\n        params: {\n          _t: timestamp\n        }\n      });\n\n      // Validate user data\n      if (((_userResponse$data$id = userResponse.data.id) === null || _userResponse$data$id === void 0 ? void 0 : _userResponse$data$id.toString()) === userId) {\n        dashboardData.user_info = userResponse.data;\n        console.log('âœ… Got user info from /user/profile');\n      } else {\n        console.warn('âš ï¸ User profile data mismatch, skipping');\n      }\n    } catch (error) {\n      console.log('âŒ /user/profile not available');\n      try {\n        var _authResponse$data$id;\n        const authResponse = await api.get('/auth/me', {\n          params: {\n            _t: timestamp\n          }\n        });\n\n        // Validate user data\n        if (((_authResponse$data$id = authResponse.data.id) === null || _authResponse$data$id === void 0 ? void 0 : _authResponse$data$id.toString()) === userId) {\n          dashboardData.user_info = authResponse.data;\n          console.log('âœ… Got user info from /auth/me');\n        } else {\n          console.warn('âš ï¸ Auth user data mismatch, skipping');\n        }\n      } catch (error) {\n        console.log('âŒ /auth/me not available');\n      }\n    }\n\n    // Try to get prediction history with user validation\n    try {\n      const predictionsResponse = await api.get('/predict/history', {\n        params: {\n          _t: timestamp\n        }\n      });\n      const predictions = predictionsResponse.data;\n      if (Array.isArray(predictions)) {\n        // CRITICAL FIX: Validate predictions belong to current user\n        const validPredictions = predictions.filter(p => {\n          if (p.user_id) {\n            return p.user_id.toString() === userId;\n          }\n          return true; // Keep if no user_id field (for backward compatibility)\n        });\n        dashboardData.recent_predictions = validPredictions.slice(0, 5);\n        dashboardData.latest_prediction = validPredictions[0] || null;\n        dashboardData.statistics.total_predictions = validPredictions.length;\n        dashboardData.statistics.recent_predictions = validPredictions.filter(p => {\n          const daysDiff = (new Date() - new Date(p.created_at)) / (1000 * 60 * 60 * 24);\n          return daysDiff <= 7;\n        }).length;\n\n        // Calculate risk distribution from validated predictions\n        const riskCounts = {\n          High: 0,\n          Moderate: 0,\n          Low: 0\n        };\n        validPredictions.forEach(p => {\n          if (p.risk_category && riskCounts.hasOwnProperty(p.risk_category)) {\n            riskCounts[p.risk_category]++;\n          }\n        });\n        dashboardData.statistics.risk_distribution = riskCounts;\n        console.log(`âœ… Got ${validPredictions.length} validated predictions from /predict/history`);\n      }\n    } catch (error) {\n      console.log('âŒ /predict/history not available');\n    }\n\n    // Try to get patient list (for doctors) with user validation\n    if (userRole === 'doctor') {\n      try {\n        const patientsResponse = await api.get('/patients', {\n          params: {\n            _t: timestamp\n          }\n        });\n        if (Array.isArray(patientsResponse.data)) {\n          // CRITICAL FIX: Validate patients belong to current doctor\n          const validPatients = patientsResponse.data.filter(patient => {\n            if (patient.doctor_id) {\n              return patient.doctor_id.toString() === userId;\n            }\n            return true; // Keep if no doctor_id field (for backward compatibility)\n          });\n          dashboardData.statistics.total_patients = validPatients.length;\n          console.log(`âœ… Got ${validPatients.length} validated patients from /patients`);\n        }\n      } catch (error) {\n        console.log('âŒ /patients not available');\n      }\n    }\n\n    // Create some recent activities based on available data\n    dashboardData.recent_activities = generateActivitiesFromData(dashboardData, userRole);\n    dashboardData.statistics.recent_activity = dashboardData.recent_activities.length;\n    console.log('ðŸ“Š Constructed dashboard data:', dashboardData);\n    return dashboardData;\n  } catch (error) {\n    var _error$response, _error$response2, _error$response3;\n    console.error('Failed to construct dashboard data:', error);\n\n    // Create a more specific error message\n    let errorMessage = 'No dashboard or related endpoints available';\n    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 500) {\n      errorMessage = 'Server error - please check backend';\n    } else if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 401) {\n      errorMessage = 'Authentication required - please login';\n    } else if (!error.response) {\n      errorMessage = 'Backend server not reachable - check if it\\'s running';\n    }\n    const enhancedError = new Error(errorMessage);\n    enhancedError.originalError = error;\n    enhancedError.status = (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status;\n    throw enhancedError;\n  }\n};\nconst generateActivitiesFromData = (data, userRole) => {\n  const activities = [];\n  if (data.latest_prediction) {\n    activities.push({\n      id: 1,\n      description: userRole === 'doctor' ? 'Patient risk assessment completed' : 'CVD risk prediction completed',\n      target: `${data.latest_prediction.risk_percentage}% risk level`,\n      date: data.latest_prediction.created_at || new Date().toISOString()\n    });\n  }\n  if (data.recent_predictions && data.recent_predictions.length > 1) {\n    activities.push({\n      id: 2,\n      description: 'Previous prediction reviewed',\n      target: 'Historical data accessed',\n      date: data.recent_predictions[1].created_at || new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()\n    });\n  }\n\n  // Add profile activity\n  activities.push({\n    id: 3,\n    description: 'Profile accessed',\n    target: 'Dashboard viewed',\n    date: new Date().toISOString()\n  });\n  return activities;\n};","map":{"version":3,"names":["api","getDashboardData","userRole","timestamp","Date","now","userId","localStorage","getItem","console","log","primaryEndpoint","response","get","params","_t","user_id","data","user_info","_response$data$user_i","responseUserId","id","toString","error","Error","statistics","total_predictions","recent_predictions","recent_activity","total_patients","risk_distribution","High","Moderate","Low","latest_prediction","recent_activities","_fetched_at","toISOString","_user_id","message","includes","fallbackEndpoints","endpoint","_response$data$user_i2","fallbackError","_fallbackError$respon","status","constructDashboardFromOtherAPIs","dashboardData","_userResponse$data$id","userResponse","warn","_authResponse$data$id","authResponse","predictionsResponse","predictions","Array","isArray","validPredictions","filter","p","slice","length","daysDiff","created_at","riskCounts","forEach","risk_category","hasOwnProperty","patientsResponse","validPatients","patient","doctor_id","generateActivitiesFromData","_error$response","_error$response2","_error$response3","errorMessage","enhancedError","originalError","activities","push","description","target","risk_percentage","date"],"sources":["C:/Users/HP/Desktop/cvd-risk-project/frontend/cvd-risk-frontend/src/services/dashboard.js"],"sourcesContent":["import api from './api';\r\n\r\nexport const getDashboardData = async (userRole) => {\r\n  try {\r\n    // CRITICAL FIX: Always ensure fresh data by adding cache-busting parameter\r\n    const timestamp = Date.now();\r\n    const userId = localStorage.getItem('current_user_id');\r\n    \r\n    console.log(`ðŸ“Š Fetching fresh dashboard data for user ${userId}, role: ${userRole}`);\r\n    \r\n    // Try the specific role endpoint first with cache-busting\r\n    const primaryEndpoint = userRole === 'doctor' ? '/dashboard/doctor' : '/dashboard/patient';\r\n    \r\n    console.log(`ðŸ“Š Trying primary dashboard endpoint: ${primaryEndpoint}`);\r\n    const response = await api.get(primaryEndpoint, {\r\n      params: { \r\n        _t: timestamp, // Cache-busting parameter\r\n        user_id: userId // Explicit user context\r\n      }\r\n    });\r\n    \r\n    console.log('âœ… Dashboard API response:', response.data);\r\n    \r\n    // CRITICAL FIX: Validate that data belongs to current user\r\n    if (response.data.user_info && userId) {\r\n      const responseUserId = response.data.user_info.id?.toString();\r\n      if (responseUserId && responseUserId !== userId) {\r\n        console.error('ðŸš¨ SECURITY ALERT: Response data belongs to different user!');\r\n        throw new Error('Data mismatch - please refresh and try again');\r\n      }\r\n    }\r\n    \r\n    // Validate response structure\r\n    if (!response.data) {\r\n      throw new Error('No data received from server');\r\n    }\r\n\r\n    // Ensure required fields exist with user context validation\r\n    const data = {\r\n      user_info: response.data.user_info || {},\r\n      statistics: response.data.statistics || {\r\n        total_predictions: 0,\r\n        recent_predictions: 0,\r\n        recent_activity: 0,\r\n        total_patients: userRole === 'doctor' ? 0 : null,\r\n        risk_distribution: { High: 0, Moderate: 0, Low: 0 }\r\n      },\r\n      latest_prediction: response.data.latest_prediction || null,\r\n      recent_predictions: response.data.recent_predictions || [],\r\n      recent_activities: response.data.recent_activities || [],\r\n      _fetched_at: new Date().toISOString(), // Track when data was fetched\r\n      _user_id: userId // Track which user this data belongs to\r\n    };\r\n\r\n    return data;\r\n    \r\n  } catch (error) {\r\n    console.error('Primary dashboard endpoint failed:', error);\r\n    \r\n    // CRITICAL FIX: Don't try fallbacks if it's a user data mismatch\r\n    if (error.message.includes('Data mismatch')) {\r\n      throw error;\r\n    }\r\n    \r\n    // Try fallback endpoints with same cache-busting and user validation\r\n    const fallbackEndpoints = [\r\n      '/dashboard',\r\n      '/api/dashboard',\r\n      `/api/dashboard/${userRole}`\r\n    ];\r\n\r\n    const timestamp = Date.now();\r\n    const userId = localStorage.getItem('current_user_id');\r\n\r\n    for (const endpoint of fallbackEndpoints) {\r\n      try {\r\n        console.log(`ðŸ“Š Trying fallback endpoint: ${endpoint}`);\r\n        const response = await api.get(endpoint, {\r\n          params: { \r\n            _t: timestamp,\r\n            user_id: userId\r\n          }\r\n        });\r\n        console.log(`âœ… Success with fallback endpoint: ${endpoint}`);\r\n        \r\n        // Validate user data again\r\n        if (response.data.user_info && userId) {\r\n          const responseUserId = response.data.user_info.id?.toString();\r\n          if (responseUserId && responseUserId !== userId) {\r\n            console.error('ðŸš¨ SECURITY ALERT: Fallback response data belongs to different user!');\r\n            continue; // Try next endpoint\r\n          }\r\n        }\r\n        \r\n        const data = {\r\n          user_info: response.data.user_info || {},\r\n          statistics: response.data.statistics || {\r\n            total_predictions: 0,\r\n            recent_predictions: 0,\r\n            recent_activity: 0,\r\n            total_patients: userRole === 'doctor' ? 0 : null,\r\n            risk_distribution: { High: 0, Moderate: 0, Low: 0 }\r\n          },\r\n          latest_prediction: response.data.latest_prediction || null,\r\n          recent_predictions: response.data.recent_predictions || [],\r\n          recent_activities: response.data.recent_activities || [],\r\n          _fetched_at: new Date().toISOString(),\r\n          _user_id: userId\r\n        };\r\n        \r\n        return data;\r\n      } catch (fallbackError) {\r\n        console.log(`âŒ Fallback endpoint ${endpoint} failed:`, fallbackError.response?.status);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // If all endpoints fail, try to construct from other APIs with user validation\r\n    console.log('ðŸ“Š All dashboard endpoints failed, trying to construct from other APIs...');\r\n    return await constructDashboardFromOtherAPIs(userRole);\r\n  }\r\n};\r\n\r\n// CRITICAL FIX: Enhanced fallback with user validation\r\nconst constructDashboardFromOtherAPIs = async (userRole) => {\r\n  try {\r\n    console.log('ðŸ“Š Constructing dashboard from available APIs...');\r\n    \r\n    const timestamp = Date.now();\r\n    const userId = localStorage.getItem('current_user_id');\r\n    \r\n    const dashboardData = {\r\n      user_info: {},\r\n      statistics: {\r\n        total_predictions: 0,\r\n        recent_predictions: 0,\r\n        recent_activity: 0,\r\n        total_patients: userRole === 'doctor' ? 0 : null,\r\n        risk_distribution: { High: 0, Moderate: 0, Low: 0 }\r\n      },\r\n      latest_prediction: null,\r\n      recent_predictions: [],\r\n      recent_activities: [],\r\n      _fetched_at: new Date().toISOString(),\r\n      _user_id: userId\r\n    };\r\n\r\n    // Try to get user info with cache-busting\r\n    try {\r\n      const userResponse = await api.get('/user/profile', {\r\n        params: { _t: timestamp }\r\n      });\r\n      \r\n      // Validate user data\r\n      if (userResponse.data.id?.toString() === userId) {\r\n        dashboardData.user_info = userResponse.data;\r\n        console.log('âœ… Got user info from /user/profile');\r\n      } else {\r\n        console.warn('âš ï¸ User profile data mismatch, skipping');\r\n      }\r\n    } catch (error) {\r\n      console.log('âŒ /user/profile not available');\r\n      try {\r\n        const authResponse = await api.get('/auth/me', {\r\n          params: { _t: timestamp }\r\n        });\r\n        \r\n        // Validate user data\r\n        if (authResponse.data.id?.toString() === userId) {\r\n          dashboardData.user_info = authResponse.data;\r\n          console.log('âœ… Got user info from /auth/me');\r\n        } else {\r\n          console.warn('âš ï¸ Auth user data mismatch, skipping');\r\n        }\r\n      } catch (error) {\r\n        console.log('âŒ /auth/me not available');\r\n      }\r\n    }\r\n\r\n    // Try to get prediction history with user validation\r\n    try {\r\n      const predictionsResponse = await api.get('/predict/history', {\r\n        params: { _t: timestamp }\r\n      });\r\n      const predictions = predictionsResponse.data;\r\n      \r\n      if (Array.isArray(predictions)) {\r\n        // CRITICAL FIX: Validate predictions belong to current user\r\n        const validPredictions = predictions.filter(p => {\r\n          if (p.user_id) {\r\n            return p.user_id.toString() === userId;\r\n          }\r\n          return true; // Keep if no user_id field (for backward compatibility)\r\n        });\r\n        \r\n        dashboardData.recent_predictions = validPredictions.slice(0, 5);\r\n        dashboardData.latest_prediction = validPredictions[0] || null;\r\n        dashboardData.statistics.total_predictions = validPredictions.length;\r\n        dashboardData.statistics.recent_predictions = validPredictions.filter(p => {\r\n          const daysDiff = (new Date() - new Date(p.created_at)) / (1000 * 60 * 60 * 24);\r\n          return daysDiff <= 7;\r\n        }).length;\r\n\r\n        // Calculate risk distribution from validated predictions\r\n        const riskCounts = { High: 0, Moderate: 0, Low: 0 };\r\n        validPredictions.forEach(p => {\r\n          if (p.risk_category && riskCounts.hasOwnProperty(p.risk_category)) {\r\n            riskCounts[p.risk_category]++;\r\n          }\r\n        });\r\n        dashboardData.statistics.risk_distribution = riskCounts;\r\n        \r\n        console.log(`âœ… Got ${validPredictions.length} validated predictions from /predict/history`);\r\n      }\r\n    } catch (error) {\r\n      console.log('âŒ /predict/history not available');\r\n    }\r\n\r\n    // Try to get patient list (for doctors) with user validation\r\n    if (userRole === 'doctor') {\r\n      try {\r\n        const patientsResponse = await api.get('/patients', {\r\n          params: { _t: timestamp }\r\n        });\r\n        if (Array.isArray(patientsResponse.data)) {\r\n          // CRITICAL FIX: Validate patients belong to current doctor\r\n          const validPatients = patientsResponse.data.filter(patient => {\r\n            if (patient.doctor_id) {\r\n              return patient.doctor_id.toString() === userId;\r\n            }\r\n            return true; // Keep if no doctor_id field (for backward compatibility)\r\n          });\r\n          \r\n          dashboardData.statistics.total_patients = validPatients.length;\r\n          console.log(`âœ… Got ${validPatients.length} validated patients from /patients`);\r\n        }\r\n      } catch (error) {\r\n        console.log('âŒ /patients not available');\r\n      }\r\n    }\r\n\r\n    // Create some recent activities based on available data\r\n    dashboardData.recent_activities = generateActivitiesFromData(dashboardData, userRole);\r\n    dashboardData.statistics.recent_activity = dashboardData.recent_activities.length;\r\n\r\n    console.log('ðŸ“Š Constructed dashboard data:', dashboardData);\r\n    return dashboardData;\r\n\r\n  } catch (error) {\r\n    console.error('Failed to construct dashboard data:', error);\r\n    \r\n    // Create a more specific error message\r\n    let errorMessage = 'No dashboard or related endpoints available';\r\n    if (error.response?.status === 500) {\r\n      errorMessage = 'Server error - please check backend';\r\n    } else if (error.response?.status === 401) {\r\n      errorMessage = 'Authentication required - please login';\r\n    } else if (!error.response) {\r\n      errorMessage = 'Backend server not reachable - check if it\\'s running';\r\n    }\r\n\r\n    const enhancedError = new Error(errorMessage);\r\n    enhancedError.originalError = error;\r\n    enhancedError.status = error.response?.status;\r\n    throw enhancedError;\r\n  }\r\n};\r\n\r\nconst generateActivitiesFromData = (data, userRole) => {\r\n  const activities = [];\r\n  \r\n  if (data.latest_prediction) {\r\n    activities.push({\r\n      id: 1,\r\n      description: userRole === 'doctor' ? 'Patient risk assessment completed' : 'CVD risk prediction completed',\r\n      target: `${data.latest_prediction.risk_percentage}% risk level`,\r\n      date: data.latest_prediction.created_at || new Date().toISOString()\r\n    });\r\n  }\r\n\r\n  if (data.recent_predictions && data.recent_predictions.length > 1) {\r\n    activities.push({\r\n      id: 2,\r\n      description: 'Previous prediction reviewed',\r\n      target: 'Historical data accessed',\r\n      date: data.recent_predictions[1].created_at || new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()\r\n    });\r\n  }\r\n\r\n  // Add profile activity\r\n  activities.push({\r\n    id: 3,\r\n    description: 'Profile accessed',\r\n    target: 'Dashboard viewed',\r\n    date: new Date().toISOString()\r\n  });\r\n\r\n  return activities;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}