{"ast":null,"code":"import api from './api';\nexport const sendChatMessage = async (message, sessionId, predictionContext = null) => {\n  // Ensure message is not empty\n  if (!message || !message.trim()) {\n    throw new Error('Message cannot be empty');\n  }\n\n  // Ensure sessionId is valid\n  if (!sessionId || !sessionId.trim()) {\n    throw new Error('Session ID is required');\n  }\n\n  // ENHANCED: Transform predictionContext to match backend schema expectations\n  let transformedContext = null;\n  if (predictionContext) {\n    transformedContext = {\n      patientId: predictionContext.patientId || predictionContext.patient_id,\n      patientName: predictionContext.patientName || predictionContext.patient_name,\n      age: predictionContext.age,\n      riskScore: predictionContext.riskScore || predictionContext.risk_score,\n      riskCategory: predictionContext.riskCategory || predictionContext.risk_category,\n      keyFactors: predictionContext.keyFactors || predictionContext.key_factors || [],\n      source: predictionContext.source || 'manual',\n      batchFile: predictionContext.batchFile\n    };\n\n    // Only include if we have at least some required data\n    if (!transformedContext.patientId && !transformedContext.riskScore && !transformedContext.riskCategory) {\n      transformedContext = null;\n    }\n  }\n  try {\n    var _transformedContext;\n    console.log('💬 Sending chat message:', {\n      sessionId: sessionId.substring(0, 8) + '...',\n      messageLength: message.length,\n      hasContext: !!transformedContext,\n      contextType: (_transformedContext = transformedContext) === null || _transformedContext === void 0 ? void 0 : _transformedContext.source\n    });\n    const response = await api.post('/chat/message', {\n      message: message.trim(),\n      session_id: sessionId.trim(),\n      prediction_context: transformedContext\n    });\n    console.log('✅ Chat message sent successfully');\n    return response.data;\n  } catch (error) {\n    var _error$response, _error$response2;\n    // Enhanced error logging for debugging\n    console.error('❌ Chat API Error:', {\n      message: error.message,\n      status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status,\n      data: (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data,\n      requestData: {\n        message: message.trim(),\n        session_id: sessionId.trim(),\n        prediction_context: transformedContext\n      }\n    });\n    throw error;\n  }\n};\nexport const getChatHistory = async (sessionId, limit = 50) => {\n  if (!sessionId || !sessionId.trim()) {\n    throw new Error('Session ID is required for chat history');\n  }\n  try {\n    console.log('📚 Fetching chat history for session:', sessionId.substring(0, 8) + '...');\n    const response = await api.get(`/chat/history/${sessionId.trim()}`, {\n      params: {\n        limit\n      }\n    });\n    const messages = response.data.messages || response.data;\n    console.log(`✅ Retrieved ${messages.length} messages from server`);\n    return Array.isArray(messages) ? messages : [];\n  } catch (error) {\n    var _error$response3;\n    console.error('❌ Chat History Error:', {\n      message: error.message,\n      status: (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status,\n      sessionId: sessionId.substring(0, 8) + '...'\n    });\n\n    // Don't throw error - let caller handle fallback to local storage\n    return [];\n  }\n};\nexport const createNewChatSession = async (sessionName = 'New Chat') => {\n  try {\n    var _response$data, _response$data$sessio;\n    console.log('🆕 Creating new chat session:', sessionName);\n    const response = await api.post('/chat/new-session', {\n      session_name: sessionName\n    });\n    console.log('✅ New chat session created:', ((_response$data = response.data) === null || _response$data === void 0 ? void 0 : (_response$data$sessio = _response$data.session_id) === null || _response$data$sessio === void 0 ? void 0 : _response$data$sessio.substring(0, 8)) + '...');\n    return response.data;\n  } catch (error) {\n    console.error('❌ Create Session Error:', error);\n    throw error;\n  }\n};\nexport const getUserChatSessions = async () => {\n  try {\n    console.log('📋 Fetching user chat sessions...');\n    const response = await api.get('/chat/sessions');\n    const sessions = response.data;\n    console.log(`✅ Retrieved ${(sessions === null || sessions === void 0 ? void 0 : sessions.length) || 0} chat sessions`);\n    return Array.isArray(sessions) ? sessions : [];\n  } catch (error) {\n    console.error('❌ Get Sessions Error:', error);\n\n    // Don't throw error - return empty array for graceful degradation\n    return [];\n  }\n};\nexport const renameChatSession = async (sessionId, newName) => {\n  try {\n    console.log('✏️ Renaming chat session:', sessionId.substring(0, 8) + '...', 'to:', newName);\n    const response = await api.put(`/chat/session/${sessionId}/rename`, {\n      new_name: newName\n    });\n    console.log('✅ Chat session renamed successfully');\n    return response.data;\n  } catch (error) {\n    console.error('❌ Rename Session Error:', error);\n    throw error;\n  }\n};\n\n// ENHANCED: Delete chat session with cleanup\nexport const deleteChatSession = async sessionId => {\n  try {\n    console.log('🗑️ Deleting chat session:', sessionId.substring(0, 8) + '...');\n    const response = await api.delete(`/chat/session/${sessionId}`);\n    console.log('✅ Chat session deleted successfully');\n    return response.data;\n  } catch (error) {\n    console.error('❌ Delete Session Error:', error);\n    throw error;\n  }\n};\n\n// ENHANCED: Sync local messages with server\nexport const syncChatHistory = async (sessionId, localMessages = []) => {\n  try {\n    console.log('🔄 Syncing chat history with server...');\n\n    // Get server messages\n    const serverMessages = await getChatHistory(sessionId);\n\n    // Simple merge strategy: combine and deduplicate by timestamp and content\n    const combined = [...localMessages];\n    const localIds = new Set(localMessages.map(msg => `${msg.message}-${msg.source}-${msg.created_at}`));\n    serverMessages.forEach(serverMsg => {\n      const msgId = `${serverMsg.message}-${serverMsg.source}-${serverMsg.created_at}`;\n      if (!localIds.has(msgId)) {\n        combined.push(serverMsg);\n      }\n    });\n\n    // Sort by timestamp\n    combined.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));\n    console.log(`✅ Synced ${combined.length} total messages (${localMessages.length} local, ${serverMessages.length} server)`);\n    return combined;\n  } catch (error) {\n    console.error('❌ Sync Error:', error);\n    // Fallback to local messages\n    return localMessages;\n  }\n};\n\n// ENHANCED: Batch upload chat messages to server\nexport const uploadChatHistory = async (sessionId, messages) => {\n  try {\n    console.log('📤 Uploading chat history to server...');\n    const response = await api.post(`/chat/session/${sessionId}/upload-history`, {\n      messages: messages\n    });\n    console.log('✅ Chat history uploaded successfully');\n    return response.data;\n  } catch (error) {\n    console.error('❌ Upload History Error:', error);\n    // Don't throw error - uploading is not critical\n    return null;\n  }\n};","map":{"version":3,"names":["api","sendChatMessage","message","sessionId","predictionContext","trim","Error","transformedContext","patientId","patient_id","patientName","patient_name","age","riskScore","risk_score","riskCategory","risk_category","keyFactors","key_factors","source","batchFile","_transformedContext","console","log","substring","messageLength","length","hasContext","contextType","response","post","session_id","prediction_context","data","error","_error$response","_error$response2","status","requestData","getChatHistory","limit","get","params","messages","Array","isArray","_error$response3","createNewChatSession","sessionName","_response$data","_response$data$sessio","session_name","getUserChatSessions","sessions","renameChatSession","newName","put","new_name","deleteChatSession","delete","syncChatHistory","localMessages","serverMessages","combined","localIds","Set","map","msg","created_at","forEach","serverMsg","msgId","has","push","sort","a","b","Date","uploadChatHistory"],"sources":["C:/Users/HP/Desktop/cvd-risk-project/frontend/cvd-risk-frontend/src/services/chat.js"],"sourcesContent":["import api from './api';\r\n\r\nexport const sendChatMessage = async (message, sessionId, predictionContext = null) => {\r\n  // Ensure message is not empty\r\n  if (!message || !message.trim()) {\r\n    throw new Error('Message cannot be empty');\r\n  }\r\n\r\n  // Ensure sessionId is valid\r\n  if (!sessionId || !sessionId.trim()) {\r\n    throw new Error('Session ID is required');\r\n  }\r\n\r\n  // ENHANCED: Transform predictionContext to match backend schema expectations\r\n  let transformedContext = null;\r\n  if (predictionContext) {\r\n    transformedContext = {\r\n      patientId: predictionContext.patientId || predictionContext.patient_id,\r\n      patientName: predictionContext.patientName || predictionContext.patient_name,\r\n      age: predictionContext.age,\r\n      riskScore: predictionContext.riskScore || predictionContext.risk_score,\r\n      riskCategory: predictionContext.riskCategory || predictionContext.risk_category,\r\n      keyFactors: predictionContext.keyFactors || predictionContext.key_factors || [],\r\n      source: predictionContext.source || 'manual',\r\n      batchFile: predictionContext.batchFile\r\n    };\r\n\r\n    // Only include if we have at least some required data\r\n    if (!transformedContext.patientId && !transformedContext.riskScore && !transformedContext.riskCategory) {\r\n      transformedContext = null;\r\n    }\r\n  }\r\n\r\n  try {\r\n    console.log('💬 Sending chat message:', {\r\n      sessionId: sessionId.substring(0, 8) + '...',\r\n      messageLength: message.length,\r\n      hasContext: !!transformedContext,\r\n      contextType: transformedContext?.source\r\n    });\r\n\r\n    const response = await api.post('/chat/message', { \r\n      message: message.trim(),\r\n      session_id: sessionId.trim(),\r\n      prediction_context: transformedContext\r\n    });\r\n\r\n    console.log('✅ Chat message sent successfully');\r\n    return response.data;\r\n  } catch (error) {\r\n    // Enhanced error logging for debugging\r\n    console.error('❌ Chat API Error:', {\r\n      message: error.message,\r\n      status: error.response?.status,\r\n      data: error.response?.data,\r\n      requestData: {\r\n        message: message.trim(),\r\n        session_id: sessionId.trim(),\r\n        prediction_context: transformedContext\r\n      }\r\n    });\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport const getChatHistory = async (sessionId, limit = 50) => {\r\n  if (!sessionId || !sessionId.trim()) {\r\n    throw new Error('Session ID is required for chat history');\r\n  }\r\n\r\n  try {\r\n    console.log('📚 Fetching chat history for session:', sessionId.substring(0, 8) + '...');\r\n    \r\n    const response = await api.get(`/chat/history/${sessionId.trim()}`, { \r\n      params: { limit }\r\n    });\r\n    \r\n    const messages = response.data.messages || response.data;\r\n    console.log(`✅ Retrieved ${messages.length} messages from server`);\r\n    \r\n    return Array.isArray(messages) ? messages : [];\r\n  } catch (error) {\r\n    console.error('❌ Chat History Error:', {\r\n      message: error.message,\r\n      status: error.response?.status,\r\n      sessionId: sessionId.substring(0, 8) + '...'\r\n    });\r\n    \r\n    // Don't throw error - let caller handle fallback to local storage\r\n    return [];\r\n  }\r\n};\r\n\r\nexport const createNewChatSession = async (sessionName = 'New Chat') => {\r\n  try {\r\n    console.log('🆕 Creating new chat session:', sessionName);\r\n    \r\n    const response = await api.post('/chat/new-session', {\r\n      session_name: sessionName\r\n    });\r\n    \r\n    console.log('✅ New chat session created:', response.data?.session_id?.substring(0, 8) + '...');\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('❌ Create Session Error:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport const getUserChatSessions = async () => {\r\n  try {\r\n    console.log('📋 Fetching user chat sessions...');\r\n    \r\n    const response = await api.get('/chat/sessions');\r\n    const sessions = response.data;\r\n    \r\n    console.log(`✅ Retrieved ${sessions?.length || 0} chat sessions`);\r\n    return Array.isArray(sessions) ? sessions : [];\r\n  } catch (error) {\r\n    console.error('❌ Get Sessions Error:', error);\r\n    \r\n    // Don't throw error - return empty array for graceful degradation\r\n    return [];\r\n  }\r\n};\r\n\r\nexport const renameChatSession = async (sessionId, newName) => {\r\n  try {\r\n    console.log('✏️ Renaming chat session:', sessionId.substring(0, 8) + '...', 'to:', newName);\r\n    \r\n    const response = await api.put(`/chat/session/${sessionId}/rename`, {\r\n      new_name: newName\r\n    });\r\n    \r\n    console.log('✅ Chat session renamed successfully');\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('❌ Rename Session Error:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// ENHANCED: Delete chat session with cleanup\r\nexport const deleteChatSession = async (sessionId) => {\r\n  try {\r\n    console.log('🗑️ Deleting chat session:', sessionId.substring(0, 8) + '...');\r\n    \r\n    const response = await api.delete(`/chat/session/${sessionId}`);\r\n    \r\n    console.log('✅ Chat session deleted successfully');\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('❌ Delete Session Error:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// ENHANCED: Sync local messages with server\r\nexport const syncChatHistory = async (sessionId, localMessages = []) => {\r\n  try {\r\n    console.log('🔄 Syncing chat history with server...');\r\n    \r\n    // Get server messages\r\n    const serverMessages = await getChatHistory(sessionId);\r\n    \r\n    // Simple merge strategy: combine and deduplicate by timestamp and content\r\n    const combined = [...localMessages];\r\n    const localIds = new Set(localMessages.map(msg => \r\n      `${msg.message}-${msg.source}-${msg.created_at}`\r\n    ));\r\n    \r\n    serverMessages.forEach(serverMsg => {\r\n      const msgId = `${serverMsg.message}-${serverMsg.source}-${serverMsg.created_at}`;\r\n      if (!localIds.has(msgId)) {\r\n        combined.push(serverMsg);\r\n      }\r\n    });\r\n    \r\n    // Sort by timestamp\r\n    combined.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));\r\n    \r\n    console.log(`✅ Synced ${combined.length} total messages (${localMessages.length} local, ${serverMessages.length} server)`);\r\n    return combined;\r\n  } catch (error) {\r\n    console.error('❌ Sync Error:', error);\r\n    // Fallback to local messages\r\n    return localMessages;\r\n  }\r\n};\r\n\r\n// ENHANCED: Batch upload chat messages to server\r\nexport const uploadChatHistory = async (sessionId, messages) => {\r\n  try {\r\n    console.log('📤 Uploading chat history to server...');\r\n    \r\n    const response = await api.post(`/chat/session/${sessionId}/upload-history`, {\r\n      messages: messages\r\n    });\r\n    \r\n    console.log('✅ Chat history uploaded successfully');\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('❌ Upload History Error:', error);\r\n    // Don't throw error - uploading is not critical\r\n    return null;\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}